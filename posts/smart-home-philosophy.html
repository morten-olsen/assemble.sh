<!DOCTYPE html><html><head><style data-styled="" data-styled-version="5.3.0">body{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;line-height:1.8em;-webkit-letter-spacing:0.5px;-moz-letter-spacing:0.5px;-ms-letter-spacing:0.5px;letter-spacing:0.5px;}/*!sc*/
a{-webkit-text-decoration:none;text-decoration:none;font-weight:700;color:red;}/*!sc*/
data-styled.g2[id="sc-global-gsOAHA1"]{content:"sc-global-gsOAHA1,"}/*!sc*/
.lmLbLR{width:100%;max-width:900px;margin:auto;}/*!sc*/
data-styled.g3[id="Layout__Content-sc-uqo7bl-0"]{content:"lmLbLR,"}/*!sc*/
.eYKdUY{font-size:0.6em;text-transform:upper-case;}/*!sc*/
data-styled.g16[id="typography__Overline-sc-10m1a84-12"]{content:"eYKdUY,"}/*!sc*/
</style><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><script type="text/javascript">
  var _paq = window._paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.mortenolsen.pro/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>The Philosophy of a Smart Home</title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-61095c13c5984b221292.js" defer=""></script><script src="/_next/static/chunks/framework-92300432a1172ef1338b.js" defer=""></script><script src="/_next/static/chunks/main-a3a79aff3ff232b41814.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9611f9caeb6619f17b4b.js" defer=""></script><script src="/_next/static/chunks/681-f6345d61c2a0591d67f7.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4267fc1ad471d41fc060.js" defer=""></script><script src="/_next/static/QWFKD_Yaw3RV43bBq-qb-/_buildManifest.js" defer=""></script><script src="/_next/static/QWFKD_Yaw3RV43bBq-qb-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="Header__Wrapper-sc-1qsleiq-0 hIRteW"><a href="/">Home</a></div><div class="Layout__Content-sc-uqo7bl-0 lmLbLR"><article><span class="typography__Overline-sc-10m1a84-12 eYKdUY">2021-04-12</span><h1 class="typography__H1-sc-10m1a84-0 gELXiG">The Philosophy of a Smart Home</h1><p>Important</p><h2>Important concepts</h2><h3>Minimal interactions</h3><p>So the first think I want to point our is <strong>connected home â‰  smart home</strong></p><p>So what do I mean by that? Let me start with an very simple example setup, that we will build upon to illustrate the different concept. Let us say that you have a setup consistant of one connected light bulb in your living room. This removed the hassel of having to get up of the couch and to to the light switch, but now in order to turn on the light you have to find your phone, unlock it, find the app and through an amount of switches turn your light on. You have merly traded on inconvinience for another.</p><p>For a smart home to be a smart home you have to have the &quot;smart&quot; part. This means that in most cases the home should figure out what to do, without you having to do anything or at least as little as possible.</p><h3>Intent driven</h3><p>So most smart home setups are event driven, where some external event is received and that does then fire an action that updates some appliances in the smart home.</p><p>To continue our example from before and actually at a bit of &quot;smart&quot; to it we will add a motion sensor. When this motion sensor detects motion it will turn the light on and if it hasn&#x27;t detected any motion for some time it will turn it of again.</p><p>Nice and simple.</p><p>But from experience I can tell you that this isn&#x27;t always the desired behavior. If for instance you are watching a movie, where you are sitting still for a longer period of time, it is suboptimal since this leads to the issue where mid-movie the light turns on because you have been sitting still for to long and the motion sensor though the room was empty, only to realize that you are still there, and doing its task of ensuring the lights are on.</p><p>To solve this you could start to listen for the TV&#x27;s state. If it is on, then turn off the motion sensor. This indead solves the problem, but it does not scale very well. As anyone who have done larger smart home setups can tell you, keeping track of all events and their effect on the home is hard. Like really hard.</p><p>One way to make this more managable in my opinion, is to add a layer in between the &quot;event -&gt; action&quot; model that is the common one on most home automation platforms, which is the intent layer. For instance in our example before when the motion sensor detects motion in the living room it will fire a &quot;Occupy room&quot; intent, and when the TV turns on it fires an &quot;Watching TV&quot; intent. Then the automations that should react to the can not see what the user wants to do instead of just some arbitary event.
This also means that this intent layer can take more input into considuration when deciding on an intent, isolating this complexity into its own layer.</p><p>To take this one step further, intents should also be able to end, so when the intent &quot;Watching TV&quot; starts, the motion sensor turn of and when the intent stops, they turn back on.</p><h3>Declarative state</h3><p>A declarative state means that you have a stored state representing the desired state of all your appliances. So the idea is that when you want to make changes to the state of your smart home you update the declarative state instead of dispatching an event to the appliance with the desired state. A reconciliation process then runs that looks at all appliances and correct any with incorrect values.</p><p>This may seem like a small distinction but comes with some great advantages. First of all your home automations become completly decopled from the integrations, meaning if you want to test something but not have all your appliances go insane while doing so, you can simply disconnect them all. The only important thing is that the desired state gets updated correctly, then the reconsiliation will take care of the rest.</p><p>The second great advantages if fault tolerance. Say a light bulb doesn&#x27;t get an action fired for it with the tradition event -&gt; action approach; this light will now be stuck in an incorrect state, until another action overrides the incorrect one. With desired state, the reconciliation process will see that the light is set incorrectly compared to the desired state and correct it.</p><h3>Destinct engine</h3><p>The last concept is to seperate the engine and the UI. A lot of the platforms out there comes with their own UI creation tools, which seems great, and is a great thing to have when first getting into home automations. The problem is that it isn&#x27;t very flexible. I want to be able to create an optimized frontend for the platform that I am working with. So if I am developing and app for the phone, I have a lot of power and can do a lot more than if I am building a small wall panel with a dot-matrix display. Therefore I prefer the engine to not bundle a UI but insted expose an easy to integrate realtime API that can work with low powered devices as well.</p><h2>Putting it all together</h2><p>Okay all the core concepts are there, so we are ready to build our platform.</p><p><strong>Event flow</strong></p><ol><li>Event enters the engine</li><li>The intent system tries to interpret the users intent</li><li>The the automations update the declarative state based on the current state and the intent received</li><li>The reconsiliation process updates any devices which does not have the desired state</li></ol><h2>Using settings group to determine desired state</h2></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"smart-home-philosophy","content":{"compiledSource":"var d=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var r=(t,e,o)=\u003ee in t?d(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,i=(t,e)=\u003e{for(var o in e||(e={}))s.call(e,o)\u0026\u0026r(t,o,e[o]);if(a)for(var o of a(e))h.call(e,o)\u0026\u0026r(t,o,e[o]);return t},l=(t,e)=\u003ec(t,m(e));var p=(t,e)=\u003e{var o={};for(var n in t)s.call(t,n)\u0026\u0026e.indexOf(n)\u003c0\u0026\u0026(o[n]=t[n]);if(t!=null\u0026\u0026a)for(var n of a(t))e.indexOf(n)\u003c0\u0026\u0026h.call(t,n)\u0026\u0026(o[n]=t[n]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var n=o,{components:t}=n,e=p(n,[\"components\"]);return mdx(MDXLayout,l(i(i({},layoutProps),e),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Important\"),mdx(\"h2\",null,\"Important concepts\"),mdx(\"h3\",null,\"Minimal interactions\"),mdx(\"p\",null,\"So the first think I want to point our is \",mdx(\"strong\",{parentName:\"p\"},\"connected home \\u2260 smart home\")),mdx(\"p\",null,\"So what do I mean by that? Let me start with an very simple example setup, that we will build upon to illustrate the different concept. Let us say that you have a setup consistant of one connected light bulb in your living room. This removed the hassel of having to get up of the couch and to to the light switch, but now in order to turn on the light you have to find your phone, unlock it, find the app and through an amount of switches turn your light on. You have merly traded on inconvinience for another.\"),mdx(\"p\",null,'For a smart home to be a smart home you have to have the \"smart\" part. This means that in most cases the home should figure out what to do, without you having to do anything or at least as little as possible.'),mdx(\"h3\",null,\"Intent driven\"),mdx(\"p\",null,\"So most smart home setups are event driven, where some external event is received and that does then fire an action that updates some appliances in the smart home.\"),mdx(\"p\",null,`To continue our example from before and actually at a bit of \"smart\" to it we will add a motion sensor. When this motion sensor detects motion it will turn the light on and if it hasn't detected any motion for some time it will turn it of again.`),mdx(\"p\",null,\"Nice and simple.\"),mdx(\"p\",null,\"But from experience I can tell you that this isn't always the desired behavior. If for instance you are watching a movie, where you are sitting still for a longer period of time, it is suboptimal since this leads to the issue where mid-movie the light turns on because you have been sitting still for to long and the motion sensor though the room was empty, only to realize that you are still there, and doing its task of ensuring the lights are on.\"),mdx(\"p\",null,\"To solve this you could start to listen for the TV's state. If it is on, then turn off the motion sensor. This indead solves the problem, but it does not scale very well. As anyone who have done larger smart home setups can tell you, keeping track of all events and their effect on the home is hard. Like really hard.\"),mdx(\"p\",null,`One way to make this more managable in my opinion, is to add a layer in between the \"event -\u003e action\" model that is the common one on most home automation platforms, which is the intent layer. For instance in our example before when the motion sensor detects motion in the living room it will fire a \"Occupy room\" intent, and when the TV turns on it fires an \"Watching TV\" intent. Then the automations that should react to the can not see what the user wants to do instead of just some arbitary event.\nThis also means that this intent layer can take more input into considuration when deciding on an intent, isolating this complexity into its own layer.`),mdx(\"p\",null,'To take this one step further, intents should also be able to end, so when the intent \"Watching TV\" starts, the motion sensor turn of and when the intent stops, they turn back on.'),mdx(\"h3\",null,\"Declarative state\"),mdx(\"p\",null,\"A declarative state means that you have a stored state representing the desired state of all your appliances. So the idea is that when you want to make changes to the state of your smart home you update the declarative state instead of dispatching an event to the appliance with the desired state. A reconciliation process then runs that looks at all appliances and correct any with incorrect values.\"),mdx(\"p\",null,\"This may seem like a small distinction but comes with some great advantages. First of all your home automations become completly decopled from the integrations, meaning if you want to test something but not have all your appliances go insane while doing so, you can simply disconnect them all. The only important thing is that the desired state gets updated correctly, then the reconsiliation will take care of the rest.\"),mdx(\"p\",null,\"The second great advantages if fault tolerance. Say a light bulb doesn't get an action fired for it with the tradition event -\u003e action approach; this light will now be stuck in an incorrect state, until another action overrides the incorrect one. With desired state, the reconciliation process will see that the light is set incorrectly compared to the desired state and correct it.\"),mdx(\"h3\",null,\"Destinct engine\"),mdx(\"p\",null,\"The last concept is to seperate the engine and the UI. A lot of the platforms out there comes with their own UI creation tools, which seems great, and is a great thing to have when first getting into home automations. The problem is that it isn't very flexible. I want to be able to create an optimized frontend for the platform that I am working with. So if I am developing and app for the phone, I have a lot of power and can do a lot more than if I am building a small wall panel with a dot-matrix display. Therefore I prefer the engine to not bundle a UI but insted expose an easy to integrate realtime API that can work with low powered devices as well.\"),mdx(\"h2\",null,\"Putting it all together\"),mdx(\"p\",null,\"Okay all the core concepts are there, so we are ready to build our platform.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Event flow\")),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Event enters the engine\"),mdx(\"li\",{parentName:\"ol\"},\"The intent system tries to interpret the users intent\"),mdx(\"li\",{parentName:\"ol\"},\"The the automations update the declarative state based on the current state and the intent received\"),mdx(\"li\",{parentName:\"ol\"},\"The reconsiliation process updates any devices which does not have the desired state\")),mdx(\"h2\",null,\"Using settings group to determine desired state\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"The Philosophy of a Smart Home","published":false,"date":"2021-04-12","summery":"My take on some of the key concept for creating an awesome smart home\n"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"smart-home-philosophy"},"buildId":"QWFKD_Yaw3RV43bBq-qb-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>