{"pageProps":{"posts":[{"id":"homelab-devops","content":{"compiledSource":"var h=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var p=(e,a,t)=>a in e?h(e,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[a]=t,n=(e,a)=>{for(var t in a||(a={}))r.call(a,t)&&p(e,t,a[t]);if(i)for(var t of i(a))s.call(a,t)&&p(e,t,a[t]);return e},d=(e,a)=>c(e,m(a));var l=(e,a)=>{var t={};for(var o in e)r.call(e,o)&&a.indexOf(o)<0&&(t[o]=e[o]);if(e!=null&&i)for(var o of i(e))a.indexOf(o)<0&&s.call(e,o)&&(t[o]=e[o]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var o=t,{components:e}=o,a=l(o,[\"components\"]);return mdx(MDXLayout,d(n(n({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"So I have a home lab, and through its existance it have been managed in pretty much every way imaginable. I have done virtualization with ESXi, XCP-NG, Proxmox, I have run dedicated docker hosts, i have run Docker Swarm and Kubernetes as HA setups with hyper convergence using Gluster on CephFS. I have used docker, docker-compose, kubectl, helm, ansible, rancher, portainer etc. for daily managment and setup tasks. So from the most bare metal setup to large (or as large as I could make it with the hardware I have) setups.\"),mdx(\"p\",null,`One thing that has been a common thread between all these setups: Managing my homelab was a pain. Especially as I went for higher availability and an \"easier\"-to-use setup, the managerial pain increased. I felt like a System Administrator in my own home. Don't get me wrong, I have respect for the profession and I don't mind the odd SysAdm task now and again, but I prefer to experiment with the actual services instead of the underlaying metal.`),mdx(\"p\",null,\"This is why I have decided to change tactics, and this post tries to explain this new approach and how you could use it in your own homelab setup, if you as me are tired of speending more time managing than developing og spinning up new interesting services.\"),mdx(\"h2\",null,\"No more HA\"),mdx(\"p\",null,\"Okay, this may be a weird path to go down, and this is most likely only a temorary path for me, but to get up and running I have decided that this time around I am not going to be focusing on high availability, but instead rely on an easy to setup and replicate setup with strong backup for restoring everything in case of a catastrofic failure. Therefor I am going to go with a single Docker node and just use host mounts for data storage. Later I will try to expand upon this using something like docker swarm or kubernetes along with hyper convergence, but atleast for now I want a simpler setup\"),mdx(\"h2\",null,\"Queue the DevOps approach\"),mdx(\"p\",null,\"As said, I am not a SysAdm, I am a developer, and therefor the DevOps approach is more near and dear to my heart, and the one I will be using for this new setup.\"),mdx(\"p\",null,\"I have been running Gitea to host some of my projects locally for a few years, and it is also what I am going to be using as configuration on project storage for this new setup. Additionally I need a CI/CD pipeline to build and deploy the projects that I host in my Gitea instance. For this perpose I will be using Drone CI with a Docker based runner.\"),mdx(\"p\",null,\"So that is basically it, nice and simple right? So the flow works like this:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Create a repo in Gitea\"),mdx(\"li\",{parentName:\"ul\"},\"Enable builds on Drone CI for the new repo\"),mdx(\"li\",{parentName:\"ul\"},\"Push the project along with a \",mdx(\"inlineCode\",{parentName:\"li\"},\".drone.yml\"),\" workflow file which will build and deploy the project\")),mdx(\"h2\",null,\"Setting up the system\"),mdx(\"p\",null,\"Okay so let us go through the initial setup. Not everythin can be automated, so it will require a few steps\"),mdx(\"p\",null,\"First clone or download the project repository from TODO\"),mdx(\"p\",null,\"Then we need to add in som environment variables. Create a \",mdx(\"inlineCode\",{parentName:\"p\"},\".env\"),\" file in the project with the follwing content (replace any values with your own)\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{}),`EXTERNAL_DOMAIN=external.loopback.services\nINTERNAL_DOMAIN=internal.loopback.services\nDATA_LOCATION=./data\nCLOUDFLARE_TOKEN=some-token-here\nCLOUDFLARE_EMAIL=you@email.here\n`)),mdx(\"p\",null,\"Okay we are ready to setup the first two components, the Gitea git server and the traefik load balancer for our web traffic\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{}),`docker network create loadbalancer\ndocker-compose -p traefik -f docker-compose-0.yml\ndocker-compose -p gitea -f docker-compose-1.yml\n`)),mdx(\"p\",null,\"Next we need to setup Drone with Gitea as the provider. The official documentation can be found \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://docs.drone.io/server/provider/gitea/\"}),\"here\")),mdx(\"p\",null,\"Navigate to \",mdx(\"inlineCode\",{parentName:\"p\"},\"https://gitea.external.loopback.services/user/settings/applications\")),mdx(\"p\",null,\"And create a new application with any name you choose and the login url as \",mdx(\"inlineCode\",{parentName:\"p\"},\"https://drone.external.loopback.services\")),mdx(\"p\",null,\"This will give you a client id and a secret which we will use in a second\"),mdx(\"p\",null,`Next we need a shared key for drone and its workers. To create this we use the method propsed by the official documentation\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"openssl rand -hex 16\"),\" which will give us a random 16 charator secret\"),mdx(\"p\",null,\"We add these new information into our \",mdx(\"inlineCode\",{parentName:\"p\"},\".env\"),\" file below our existing values\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{}),`GITEA_CLIENT_ID=92491bfe-26ae-464e-8d75-7b7632ecce05\nGITEA_CLIENT_SECRET=bx5vThgdfYRNqBV8rDGySyrZxeAuYaMXakXWm0IX6mM=\nDRONE_RPC_SECRET=7dde7b625f9dc30cd3a8fb8f1a614dcc\nDRONE_ADMIN=the-gitea-admin-user-name\n\n`)),mdx(\"p\",null,\"Ready to rock!\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{}),`docker-compose -p drone -f docker-compose-2.yml\n`)),mdx(\"p\",null,\"Now go to \",mdx(\"inlineCode\",{parentName:\"p\"},\"https://drone.external.loopback.services\"),\" and complete the setup\"),mdx(\"p\",null,\"Congratulation, setup is done! No more SysAdm, just DevOps from here\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"Homelabing, the DevOps way","date":"2021-07-25","summery":"An introduction to my new way to manage my homelab, DevOps style!"},{"id":"hyperconnect-part-1","content":{"compiledSource":"var c=Object.defineProperty,p=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(e,t,o)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,i=(e,t)=>{for(var o in t||(t={}))s.call(t,o)&&l(e,o,t[o]);if(n)for(var o of n(t))r.call(t,o)&&l(e,o,t[o]);return e},h=(e,t)=>p(e,u(t));var d=(e,t)=>{var o={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(o[a]=e[a]);if(e!=null&&n)for(var a of n(e))t.indexOf(a)<0&&r.call(e,a)&&(o[a]=e[a]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var a=o,{components:e}=a,t=d(a,[\"components\"]);return mdx(MDXLayout,h(i(i({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"em\",{parentName:\"p\"},\"This is part 1, which will focus on the principal behind the project. Stay tuned for part two where we will start to implement this in node.js\")),mdx(\"p\",null,\"Hyper connectivity is about being available on multitude of different connections, you properly know someone who will call you on the phone, asking about the notes they shared on Slack in regards to the Teams meeting. This person is hyper connected. But what does being hyper connected mean for a series of silicon based devices?\"),mdx(\"p\",null,\"Well first we need to talk about Apple. So usually people can be categorized as an Apple Fanboy or an Apple hater. I my self am not outside of this polarized scale, but rather I am both at the same time! I hate the closed down ecosystem, and have time and time again tried to extradite myself from said ecosystem only to find my self getting drawn back in and doubling down. At the moment I have pretty much all category of Apple based devices; iPhone, iPad, MacBook, Apple Watch, Apple TV, Air Pods, Apple Pen and the list goes on.\"),mdx(\"p\",null,\"So why is it I keep coming back? Well it is about device inter connectivity. In Apple-land every device seems to just talk to every other device, regardless of its hardware. If it is registered to the same user, they simple just find a way to talk to each other, not fiddling around required.\"),mdx(\"p\",null,\"I have tried to mimic this in countless setups based around open source technologies, but while making two devices talk together is trivial with some time spend on setup, making any device just connect is not really something I have come across outside of the Apple ecosystem.\"),mdx(\"p\",null,\"This got me thinking; Why and how?\"),mdx(\"h2\",null,\"The why\"),mdx(\"p\",null,\"So why is this? Open source land is filled with talented developers, surely they should be able to make something like this work right?\"),mdx(\"p\",null,\"Well one issue is that a lot of the time for open source projects these are based on the current communication standards. A lot of the time HTTP. So HTTP allow one computer to connect to another and communicate over the HTTP protocol given that the caller knows the IP of the receiver. HTTP does not solve discoverability nor authentication so each project has to apply their own way of discovering a service (Usually entering a host name or an IP in a user interface) and a means of authentication (Usually a login prompt in a user interface).\"),mdx(\"p\",null,\"Both of those require interaction on the users part to establish a connection and isn\\u2019t really interchangeable between different applications using different discovery and authorization mechanisms.\"),mdx(\"p\",null,\"Standardized ways of device discovery such as mDNS/Avahi does exists, but usually only announce a service\\u2019s existence, and require that the application looking and the application found are of the same type.\"),mdx(\"p\",null,\"There also exists standardized ways of doing authorization, such as Open ID Connect, but it is an interactive login process by design, which if we just want our devices to connect, if owned by the same user, isn\\u2019t really going to solve our problem.\"),mdx(\"h2\",null,\"The how\"),mdx(\"p\",null,\"So can we create something that will create device hyper connectivity? Before we start, let\\u2019s define a few framework our solution should solve. I will also add a few requirements, not specified in the \\u201Cwhy\\u201D, but should help ensure that our framework should be good and solid and work anywhere\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Any already authenticated device should be able to connect to any device authenticated as the same user without requiring interaction.\"),mdx(\"li\",{parentName:\"ul\"},\"All communication should be done with end-to-end encryption, and with secure handshaking.\"),mdx(\"li\",{parentName:\"ul\"},\"Should be able to use different underlying transport mechanisms such as internet, Bluetooth LE etc.\"),mdx(\"li\",{parentName:\"ul\"},\"Should be able to resume a dropped connection, or find an alternative connection to a device without packet loss.\"),mdx(\"li\",{parentName:\"ul\"},\"Should be opaque to the developer using the framework. (Mimicking the API of using TCP listener and clients).\")),mdx(\"p\",null,\"And one last bonus requirement\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Should be able to set up proxy chains between devices to traverse network incompatibility (As an example, if a Bluetooth LE device wants to connect to an internet only device it could use another device with both Bluetooth LE and internet as a bridge device for the connection.\")),mdx(\"p\",null,\"Okay, list of overly complicated tasks to completed: check.\"),mdx(\"p\",null,\"So in the next part we will start to create the foundation for all of this. But before we go, I\\u2019ll just lift the vial of one aspect of the technical implementation. I am going to be developing this in node.js using the Stream type. The reason I am using node.js\\u2019 Stream is that it has a lot of great build in features that is going to make this project a lot easier and it is the platform I am most familiar with (No reason to add further complexity by also trying to learn a new language).\"),mdx(\"p\",null,\"In the real world this should be build in a low level language and bound to higher level languages for the best performance and interoperability, as well as be made into a standardized format, so any platform not able to bind the the library directly could create a client native to the platform.\"),mdx(\"p\",null,\"But I think that it is for now, stay tuned for part two, when we are actually going to be playing around with some code!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"Creating a Hyper-connected Framework (Part 1)","date":"2021-07-11","summery":"Part one of a series about creating a framework for connecting everything over any connection","image":"hyperconnect-part-1.png"},{"id":"smart-home-philosophy","content":{"compiledSource":"var d=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable;var r=(t,e,o)=>e in t?d(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,i=(t,e)=>{for(var o in e||(e={}))s.call(e,o)&&r(t,o,e[o]);if(a)for(var o of a(e))h.call(e,o)&&r(t,o,e[o]);return t},l=(t,e)=>c(t,m(e));var p=(t,e)=>{var o={};for(var n in t)s.call(t,n)&&e.indexOf(n)<0&&(o[n]=t[n]);if(t!=null&&a)for(var n of a(t))e.indexOf(n)<0&&h.call(t,n)&&(o[n]=t[n]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var n=o,{components:t}=n,e=p(n,[\"components\"]);return mdx(MDXLayout,l(i(i({},layoutProps),e),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Important\"),mdx(\"h2\",null,\"Important concepts\"),mdx(\"h3\",null,\"Minimal interactions\"),mdx(\"p\",null,\"So the first think I want to point our is \",mdx(\"strong\",{parentName:\"p\"},\"connected home \\u2260 smart home\")),mdx(\"p\",null,\"So what do I mean by that? Let me start with an very simple example setup, that we will build upon to illustrate the different concept. Let us say that you have a setup consistant of one connected light bulb in your living room. This removed the hassel of having to get up of the couch and to to the light switch, but now in order to turn on the light you have to find your phone, unlock it, find the app and through an amount of switches turn your light on. You have merly traded on inconvinience for another.\"),mdx(\"p\",null,'For a smart home to be a smart home you have to have the \"smart\" part. This means that in most cases the home should figure out what to do, without you having to do anything or at least as little as possible.'),mdx(\"h3\",null,\"Intent driven\"),mdx(\"p\",null,\"So most smart home setups are event driven, where some external event is received and that does then fire an action that updates some appliances in the smart home.\"),mdx(\"p\",null,`To continue our example from before and actually at a bit of \"smart\" to it we will add a motion sensor. When this motion sensor detects motion it will turn the light on and if it hasn't detected any motion for some time it will turn it of again.`),mdx(\"p\",null,\"Nice and simple.\"),mdx(\"p\",null,\"But from experience I can tell you that this isn't always the desired behavior. If for instance you are watching a movie, where you are sitting still for a longer period of time, it is suboptimal since this leads to the issue where mid-movie the light turns on because you have been sitting still for to long and the motion sensor though the room was empty, only to realize that you are still there, and doing its task of ensuring the lights are on.\"),mdx(\"p\",null,\"To solve this you could start to listen for the TV's state. If it is on, then turn off the motion sensor. This indead solves the problem, but it does not scale very well. As anyone who have done larger smart home setups can tell you, keeping track of all events and their effect on the home is hard. Like really hard.\"),mdx(\"p\",null,`One way to make this more managable in my opinion, is to add a layer in between the \"event -> action\" model that is the common one on most home automation platforms, which is the intent layer. For instance in our example before when the motion sensor detects motion in the living room it will fire a \"Occupy room\" intent, and when the TV turns on it fires an \"Watching TV\" intent. Then the automations that should react to the can not see what the user wants to do instead of just some arbitary event.\nThis also means that this intent layer can take more input into considuration when deciding on an intent, isolating this complexity into its own layer.`),mdx(\"p\",null,'To take this one step further, intents should also be able to end, so when the intent \"Watching TV\" starts, the motion sensor turn of and when the intent stops, they turn back on.'),mdx(\"h3\",null,\"Declarative state\"),mdx(\"p\",null,\"A declarative state means that you have a stored state representing the desired state of all your appliances. So the idea is that when you want to make changes to the state of your smart home you update the declarative state instead of dispatching an event to the appliance with the desired state. A reconciliation process then runs that looks at all appliances and correct any with incorrect values.\"),mdx(\"p\",null,\"This may seem like a small distinction but comes with some great advantages. First of all your home automations become completly decopled from the integrations, meaning if you want to test something but not have all your appliances go insane while doing so, you can simply disconnect them all. The only important thing is that the desired state gets updated correctly, then the reconsiliation will take care of the rest.\"),mdx(\"p\",null,\"The second great advantages if fault tolerance. Say a light bulb doesn't get an action fired for it with the tradition event -> action approach; this light will now be stuck in an incorrect state, until another action overrides the incorrect one. With desired state, the reconciliation process will see that the light is set incorrectly compared to the desired state and correct it.\"),mdx(\"h3\",null,\"Destinct engine\"),mdx(\"p\",null,\"The last concept is to seperate the engine and the UI. A lot of the platforms out there comes with their own UI creation tools, which seems great, and is a great thing to have when first getting into home automations. The problem is that it isn't very flexible. I want to be able to create an optimized frontend for the platform that I am working with. So if I am developing and app for the phone, I have a lot of power and can do a lot more than if I am building a small wall panel with a dot-matrix display. Therefore I prefer the engine to not bundle a UI but insted expose an easy to integrate realtime API that can work with low powered devices as well.\"),mdx(\"h2\",null,\"Putting it all together\"),mdx(\"p\",null,\"Okay all the core concepts are there, so we are ready to build our platform.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Event flow\")),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Event enters the engine\"),mdx(\"li\",{parentName:\"ol\"},\"The intent system tries to interpret the users intent\"),mdx(\"li\",{parentName:\"ol\"},\"The the automations update the declarative state based on the current state and the intent received\"),mdx(\"li\",{parentName:\"ol\"},\"The reconsiliation process updates any devices which does not have the desired state\")),mdx(\"h2\",null,\"Using settings group to determine desired state\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"The Philosophy of a Smart Home","published":false,"date":"2021-04-12","summery":"My take on some of the key concept for creating an awesome smart home\n"}]},"__N_SSG":true}